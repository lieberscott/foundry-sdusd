{
  "language": "Solidity",
  "sources": {
    "contracts/Algo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Algo {\n    // Emoji range [U+1F300..U+1F5FF]\n    uint32 constant EMOJI_START = 0x1F300;\n    uint32 constant EMOJI_END   = 0x1F5FF;\n    uint32 constant EMOJI_SIZE  = EMOJI_END - EMOJI_START + 1;\n\n    // Width for the ASCII text portion\n    uint256 constant ASCII_WIDTH = 16;\n\n    /**\n     * @dev Generate 3 lines:\n     * \n     *   1) [emojiLeft] SDNFT [emojiRight]\n     *   2) [emojiLeft] No. XXXXX [emojiRight]\n     *   3) [emojiLeft] 10,000 Votes [emojiRight]\n     *\n     * Where each ASCII text is centered within ASCII_WIDTH,\n     * and emojis simply wrap around (no truncation on the final line).\n     */\n    function generateArt(uint256 tokenId) public pure returns (string memory) {\n        // Pseudorandom seed\n        uint256 rand = uint256(keccak256(abi.encodePacked(\"MySalt\", tokenId)));\n\n        // We’ll build the final string line by line\n        bytes memory output;\n\n        // LINE 1: \"SDNFT\"\n        {\n            // 1. Pick 2 random emojis\n            (bytes memory left, uint256 rand2) = pickEmoji(rand);\n            (bytes memory right, uint256 rand3) = pickEmoji(rand2);\n            rand = rand3;\n\n            // 2. Center the ASCII portion\n            string memory asciiText = centerASCII(\"SDNFT\", ASCII_WIDTH);\n\n            // 3. Combine: leftEmoji + asciiText + rightEmoji + newline\n            bytes memory line = abi.encodePacked(left, asciiText, right, \"\\n\");\n            output = abi.encodePacked(output, line);\n        }\n\n        // LINE 2: \"No. XXXXX\"\n        {\n            (bytes memory left, uint256 rand2) = pickEmoji(rand);\n            (bytes memory right, uint256 rand3) = pickEmoji(rand2);\n            rand = rand3;\n\n            // ASCII text includes the tokenId\n            string memory asciiText = string(\n                abi.encodePacked(\"No. \", toString(tokenId))\n            );\n            asciiText = centerASCII(asciiText, ASCII_WIDTH);\n\n            bytes memory line = abi.encodePacked(left, asciiText, right, \"\\n\");\n            output = abi.encodePacked(output, line);\n        }\n\n        // LINE 3: \"10,000 Votes\"\n        {\n            (bytes memory left, uint256 rand2) = pickEmoji(rand);\n            (bytes memory right, uint256 rand3) = pickEmoji(rand2);\n            rand = rand3;\n\n            string memory asciiText = centerASCII(\"10,000 Votes\", ASCII_WIDTH);\n\n            bytes memory line = abi.encodePacked(left, asciiText, right, \"\\n\");\n            output = abi.encodePacked(output, line);\n        }\n\n        // Convert the final buffer to a string\n        return string(output);\n    }\n\n    /**\n     * @dev pickEmoji: returns a random emoji (in UTF-8 bytes) plus updated rand.\n     */\n    function pickEmoji(uint256 rand)\n        internal\n        pure\n        returns (bytes memory emojiBytes, uint256 newRand)\n    {\n        uint256 idx = rand % EMOJI_SIZE;\n        uint32 codePoint = EMOJI_START + uint32(idx);\n\n        // Shift bits for the next call\n        newRand = rand >> 16;\n\n        // Encode to UTF-8\n        emojiBytes = utf8Encode(codePoint);\n    }\n\n    /**\n     * @dev centerASCII: center an ASCII string in `width`, by adding spaces on both sides.\n     *      If the string is longer than `width`, we can truncate *only* ASCII text.\n     *      This avoids slicing multi-byte emojis, since emojis aren’t included here.\n     */\n    function centerASCII(string memory text, uint256 width) internal pure returns (string memory) {\n        bytes memory raw = bytes(text);\n        if (raw.length >= width) {\n            // If it's too long, truncate at width (safe for ASCII)\n            bytes memory truncated = new bytes(width);\n            for (uint256 i = 0; i < width; i++) {\n                truncated[i] = raw[i];\n            }\n            return string(truncated);\n        }\n\n        // Otherwise, left-pad and right-pad with spaces\n        uint256 totalSpaces = width - raw.length;\n        uint256 leftSpaces = totalSpaces / 2;\n        uint256 rightSpaces = totalSpaces - leftSpaces;\n\n        return string(abi.encodePacked(\n            repeatSpace(leftSpaces),\n            text,\n            repeatSpace(rightSpaces)\n        ));\n    }\n\n    // Repeat N spaces\n    function repeatSpace(uint256 count) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(count);\n        for (uint256 i = 0; i < count; i++) {\n            buffer[i] = 0x20; // space\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev UTF-8 encode a single code point (e.g., emoji).\n     */\n    function utf8Encode(uint32 cp) internal pure returns (bytes memory) {\n        require(cp <= 0x10FFFF && (cp < 0xD800 || cp > 0xDFFF), \"Invalid codepoint\");\n\n        if (cp <= 0x7F) {\n            bytes memory b = new bytes(1);\n            b[0] = bytes1(uint8(cp));\n            return b;\n        } else if (cp <= 0x7FF) {\n            bytes memory b = new bytes(2);\n            b[0] = bytes1(uint8(0xC0 | (cp >> 6)));\n            b[1] = bytes1(uint8(0x80 | (cp & 0x3F)));\n            return b;\n        } else if (cp <= 0xFFFF) {\n            bytes memory b = new bytes(3);\n            b[0] = bytes1(uint8(0xE0 | (cp >> 12)));\n            b[1] = bytes1(uint8(0x80 | ((cp >> 6) & 0x3F)));\n            b[2] = bytes1(uint8(0x80 | (cp & 0x3F)));\n            return b;\n        } else {\n            bytes memory b = new bytes(4);\n            b[0] = bytes1(uint8(0xF0 | (cp >> 18)));\n            b[1] = bytes1(uint8(0x80 | ((cp >> 12) & 0x3F)));\n            b[2] = bytes1(uint8(0x80 | ((cp >> 6) & 0x3F)));\n            b[3] = bytes1(uint8(0x80 | (cp & 0x3F)));\n            return b;\n        }\n    }\n\n    // Convert uint to string (decimal); use OZ Strings for production\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + (value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}